package cnfGenerator;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

public class TextParser {
	
		
		public static HashMap<String, Integer> variables = new HashMap<String, Integer>();			//Hashmap to look up CNF variables vs node names from file
		public static int varcount = 1;																//counter keeps track of the number of nodes in the circuit
		public static int clausecount = 0;															//counter keeps track of the total number of clauses  produced
		public static List<String> output = new ArrayList<String>();									//A list that holds all of the text to be output to the text file
	
		public static void main(String[] args) {
			
		    
			List<String> var_lines = new ArrayList<String>(); 										//list for storing lines of verilog describing nets
			List<String> andgates= new ArrayList<String>();											//list for storing lines of verilog describing gates
			List<String> notgates= new ArrayList<String>();	
			BufferedReader reader;
		
			try {
				reader = new BufferedReader(new FileReader(
						"/Users/rickbrownscomputer/Desktop/Embedded Systems/Lab1/lab1_files/ex1.v")); //opens the verilog file
				String line = reader.readLine(); 													//stores first line of the verilog file in a string
				while (line != null) { 																//while not EOF
					if ((line.contains("input") && line.contains("clock") == false) || line.contains("reg") || line.contains("wire") || line.contains("output")){
						var_lines.add(line); 														//create a dynamic list of all lines that contain inputs, registers, or wires
					}
					else if (line.contains("and")){
						andgates.add(line); 															//create a dynamic list of all lines that contain gates
					}
					else if(line.contains("not")) {
						notgates.add(line);
					}
					line = reader.readLine();   														//read the next line
				}
				String[] var_array = var_lines.toArray(new String[var_lines.size()]); 				//convert dynamic list to an array for easy looping
				initVariables(var_array); 															//parse the lines and store them in the hash map
				String[] andgate_array = andgates.toArray(new String[andgates.size()]);				//convert dynamic list to an array for easy looping
				String[] notgate_array = notgates.toArray(new String[notgates.size()]);				//convert dynamic list to an array for easy looping
				parseNotGate(notgate_array);															//parse and form the cnf clauses for not gates
				andParse(andgate_array);																//parse and form the cnf clauses for and gates
				output.add(0, "p cnf" + " " + (varcount - 1) + " " + clausecount);
				String[] textoutput = output.toArray(new String[output.size()]);						//convert the output list to an array for easy looping
				toTextFile(textoutput);																//send the text to be written to an output file
				
				
				//create new text file and spit out the text
				reader.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		
		public static void initVariables(String[] variable_lines) {
			
			for(int i = 0; i < variable_lines.length; i++) {
				String s = variable_lines[i].substring(variable_lines[i].indexOf(" ")+1); 			//cut off the first word of the line that defines the port
			    s = s.substring(0, s.length() - 1); 													//cut off the semi colon at the end of each line
				String[] parsedline = s.split(",");												    //split up the rest of the line at each comma
				for(int j = 0; j < parsedline.length; j++) {
					variables.put(parsedline[j], varcount); 											//convert each node name to a variable 
					varcount++; 																		//keep track of total number of variables in the circuit
			}
		}
			//System.out.println(variables); //test
			
			
			
	}
	
		public static void parseNotGate(String[] nots) {
			String[] vars;
			for(int i = 0; i< nots.length; i++) {
				vars = gateParse(nots[i]);															 //parse the incoming line
				output.add(variables.get(vars[1])*(-1) + " " + (-1)*variables.get(vars[0])+ " " + 0);	 //notA or notX
				clausecount++;
				output.add(variables.get(vars[1]) + " " + variables.get(vars[0]) + " " + 0);			 //A or X
				clausecount++;
			}
				
		
		}
		
		public static void andParse(String[] ands) {
			 String[] vars;
			 for(int i = 0; i < ands.length; i++) {			 
			 vars = gateParse(ands[i]);													            //parse the incoming line
			 output.add(variables.get(vars[1]) + " " + (-1)*variables.get(vars[0]) + " " + 0);   		//A or notX
			 clausecount++;
			 output.add(variables.get(vars[2]) + " " + (-1)*variables.get(vars[0])+ " " + 0); 		//B or notX
			 clausecount++;
			 output.add((-1)*variables.get(vars[1]) + " " + (-1)*variables.get(vars[2]) + " " + variables.get(vars[0]) + " " + 0);   //notA nor notB or X
			 clausecount++; 
			 }
		}
		
		
		public static String[] gateParse(String s) {
			
			String str = s.substring(s.indexOf("(")+1);												//remove opening parenthesis from line
			str = str.substring(0, str.length() - 2);												//remove the semi-colon and closing parenthesis from line
			String[] parsedline = str.split(",");													//split the line at each comma
			return parsedline;
			
		}
		
		public static void toTextFile(String[] text) {
			PrintWriter writer;
			try {
				writer = new PrintWriter("/Users/rickbrownscomputer/Desktop/CNFTEST1", "UTF-8");		//create a new output text file
				for(int i = 0; i < text.length; i++) {
					writer.println(text[i]);															//write the dimacs formula
				}
				
				writer.close();
				
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (UnsupportedEncodingException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
		}
}
